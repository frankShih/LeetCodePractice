import gc
'''
剛學習 Python時總是會有人告訴你，萬物皆對像。Python中每一個對象的核心
就是一個結構體PyObject，它的內部有一個引用計數器（ob_refcnt）。


typedef struct_object {
    int ob_refcnt
    struct_typeobject * ob_type
} PyObject
'''


'''
Python 語言默認採用的垃圾收集機制是 "引用計數法Reference Counting"

1、導致引用計數 +1 的情況
對像被創建，例如 a=23
對像被引用，例如 b=a
對像被作為參數，傳入到一個函數中，例如 func(a)
對像作為一個元素，存儲在容器中，例如 list1=[a,a]

2、導致引用計數 -1 的情況
對象的別名被顯式銷毀，例如 del a
對象的別名被賦予新的對象，例如 a=24
對象離開它的作用域，例如函數執行完畢時，函數中的局部變量（全局變量不會）
對象所在的容器被銷毀，或從容器中刪除對象

優：
簡單，實時性（一旦為零就不跟你多BB，做掉）

缺：
維護性高（額外佔用一部分資源，雖然邏輯簡單但麻煩。
好比你吃草莓，吃一次洗一下手，而不是吃完洗手。

'''
# 不能解決的情況 --> 循環引用
a = {}        # 对象A的引用计数为 1
b = {}        # 对象B的引用计数为 1
a['b'] = b     # B的引用计数增1
b['a'] = a     # A的引用计数增1
del a          # A的引用减 1，最后A对象的引用为 1
del b          # B的引用减 1, 最后B对象的引用为 1

# 它會駐留在內存中，造成內存洩漏（內存空間在使用完畢後未釋放）。
# 為了解決對象的循環引用問題，Python 引入1.標記-清除2.分代回收 機制

'''
『標記清除（Mark—Sweep）』是種基於追踪回收（tracing GC）技術實現的
垃圾回收算法。分為兩個階段：
第一階段 GC 把所有『活動對象』打上標記
第二階段 把沒有標記的『非活動對象』進行回收

對象之間通過引用（指針）連在一起，構成一個有向圖，對象構成有向圖的節點，
而引用關係構成這個有向圖的邊。從根對象（root object）出發，
沿著有向邊遍歷，reachable 為活動對象，others 是要被清除的非活動對象。
根對象就是全局變量、調用棧、寄存器。

標記清除算法作為 Python的輔助垃圾收集技術. 主要處理容器對象，
比如 list、dict、tuple，class instance等。Python 使用一個雙向鍊錶將
這些容器對象組織起來(為了追踪容器對象，每個容器維護兩個額外的指針，
用來組成一個鍊錶，指針分別指向前後兩個容器對象，方便插入和刪除操作)。

這種簡單粗暴的標記清除算法也有明顯的缺點：
清除非活動的對象前它必須順序掃描整個內存，哪怕只剩下小部分活動對像
也要掃描所有對象。

一次gc垃圾回收步驟：
1，使得gc_refs等於容器物件的引用計數。
2，遍歷容器物件(a)，找到它(a)所引用的其它容器物件(b)，將(b)的gc_refs減去1。
3，將所有gc_refs>0的容器物件取出，組成新佇列(被容器物件佇列外部所引用)
4，被新佇列的容器物件，所引用的容器物件(舊佇列中)也加入新佇列裡。
5，釋放舊佇列剩下的容器物件。（釋放時，所引用的物件的引用計數要減1）
'''

# 從A出發，將B引用計數減1；順著引用達到B，將A引用減1，就完成循環引用環摘除
# 去掉以後發現，a ,b循環引用變為0，所以就到 unreachable鍊錶中直接被做掉

a = [1, 3]
b = [2, 4]
a.append(b)
b.append(a)
del a
del b

# 簡單一看那b取環後引用計數還為1，但是a取環就為0。這時a已進入unreachable鍊錶，
# 但是這時 root鍊錶中有b。如果a被做掉，那...
# 在root鍊錶中的b會被進行引用檢測引用了a，如果a被做掉了，那麼b就... ，
# 一審完事，二審a無罪，所以被拉到了root鍊錶中。
a = [1, 3]
b = [2, 4]
a.append(b)
b.append(a)
del a

# 之所以剖成兩個鍊錶，是基於這種考慮：unreachable可能存在被root鍊錶中的對象，
# 直接或間接引用的對象，這些是不能被回收的，一旦在標記的過程中發現這樣的對象，
# 將其從 unreachable鍊錶中移到root鍊錶中；當完成標記後，unreachable鍊錶中
# 剩下的就是垃圾對象，接下來的GC只需限制在 unreachable鍊錶中即可。


'''
分代回收
如果存在循環引用，創建>釋放數量，當創建與釋放數量的差值達到閾值時，
分代回收機制就登場啦。

以空間換時間的操作方式，Python將內存根據對象的存活時間劃分為不同集合，
每個集合為一代，Python內存分為年輕代（第0代）、中年代（第1代）、老年代（第2代），
對應3個鍊錶，GC頻率與對象存活時間反比。新創建的對像都會分配在年輕代，
年輕代鍊錶達到上限時，觸發GC機制，把可回收對象回收掉，而不回收的對象
就被移到中年代，老年代對像存活時間最久，甚至是存活於整個系統的生命週期內。

gc每一代垃圾回收所觸發的閾值。e.g. 從上一次第0代 gc後，如果分配個數減去
釋放對象的個數>threshold0，就對第0代中的對象進行gc垃圾回收檢查。類推


分代回收是建立在標記清除基礎上。分代回收作為 Python的輔助GC技術處理
那些容器對象
'''

'''
1.項目中避免循環引用
2.引入 gc模塊，啟動 gc模塊的自動清理循環引用的對像機制
3.由於分代收集，所以把需要長期使用的變量集中管理，並儘快移到二代以後，
減少GC檢查時的消耗
4.gc模塊唯一處理不了的是循環引用的類都有__del__方法，所以項目中要避免
定義__del__方法，如果一定要使用該方法，同時導致了循環引用，
e.g. a物件 __del__() 可能呼叫b; b物件__del__()可能呼叫a。
需要代碼顯式調用 gc.garbage裡對象的__del__來打破僵局
'''

import weakref
class Foo(object):
    pass
a = Foo()
a.bar = 123
a.bar2 = 123
# del a.bar2
# del a
b = weakref.ref(a)
print(b().bar)
print(a == b())
c = weakref.proxy(a)
print(c.bar)
print(c == a)
'''
weak.ref：返回a物件的引用，但不會讓a物件的引用計數+1。
            每次都得通過b()來獲取a物件。
weak.proxy：相對於weakref.ref更透明的操作，直接通過c就獲取a物件。
'''


class A(object):
    def __del__(self):
        print('__del__ in A')


class B(object):
    def __del__(self):
        print('__del__ in B')


class C(object):
    pass


print('collect: ', gc.collect())
print('garbage: ', gc.garbage)
a = A()
b = B()
c = C()
a.cc = c
c.bb = b
b.aa = a
del a, b, c
print('collect: ', gc.collect())
print('garbage: ', gc.garbage)
del gc.garbage[0].cc  # 當然，這是在我們知道第一個物件是 a的情況下，手動破除引用迴圈中的環
del gc.garbage[:]  # 消除garbage對a和b物件的引用，這樣引用計數減1等於0，就能回收a、b、c三個物件了
print('garbage: ', gc.garbage)
print('----------------------------')
print('collect: ', gc.collect())
print('garbage: ', gc.garbage)
